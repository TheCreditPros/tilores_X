/**
 * Enhanced Dashboard Component Tests
 *
 * Updated tests for the Enhanced tilores_X Dashboard v2.0 functionality.
 * Tests component rendering, API integration, data transformation, and new features.
 */

import { render, screen, waitFor } from '@testing-library/react';
import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest';
import axios from 'axios';
import App from '../src/App';
import {
  fetchVirtuousCycleStatus,
  transformToDashboardData
} from '../src/services/dataService';

// Mock axios
vi.mock('axios');
const mockedAxios = vi.mocked(axios);

// Mock data for testing
const mockApiResponse = {
  monitoring_active: true,
  langsmith_available: true,
  frameworks_available: true,
  quality_threshold: 0.90,
  last_optimization: null,
  metrics: {
    traces_processed: 24900,
    quality_checks: 156,
    optimizations_triggered: 3,
    improvements_deployed: 2,
    current_quality: 0.947,
    last_update: new Date().toISOString()
  },
  component_status: {
    langsmith_client: true,
    quality_collector: true,
    phase2_orchestrator: true,
    phase3_orchestrator: true,
    phase4_orchestrator: true
  }
};

describe('Enhanced Dashboard Tests', () => {
  beforeEach(() => {
    // Reset mocks before each test
    vi.clearAllMocks();
  });

  afterEach(() => {
    // Clean up after each test
    vi.restoreAllMocks();
  });

  describe('Component Rendering', () => {
    test('renders enhanced dashboard without crashing', async () => {
      // Mock successful API response
      mockedAxios.create.mockReturnValue({
        get: vi.fn().mockResolvedValue({ data: mockApiResponse }),
        interceptors: {
          response: {
            use: vi.fn()
          }
        }
      });

      render(<App />);

      // Check that main dashboard elements are present
      await waitFor(() => {
        expect(screen.getByText(/tilores_X AI Dashboard/i)).toBeInTheDocument();
      });
    });

    test('displays enhanced KPI cards', async () => {
      // Mock successful API response
      mockedAxios.create.mockReturnValue({
        get: vi.fn().mockResolvedValue({ data: mockApiResponse }),
        interceptors: {
          response: {
            use: vi.fn()
          }
        }
      });

      render(<App />);

      await waitFor(() => {
        // Check for enhanced KPI elements
        const qualityElement = screen.queryByText(/Overall Quality Score/i);
        const tracesElement = screen.queryByText(/Total Traces Processed/i);
        const optimizationElement = screen.queryByText(/Optimization Triggers/i);
        const uptimeElement = screen.queryByText(/System Uptime/i);

        // At least one should be present
        expect(qualityElement || tracesElement || optimizationElement || uptimeElement).toBeTruthy();
      });
    });

    test('displays enhanced phase cards', async () => {
      // Mock successful API response
      mockedAxios.create.mockReturnValue({
        get: vi.fn().mockResolvedValue({ data: mockApiResponse }),
        interceptors: {
          response: {
            use: vi.fn()
          }
        }
      });

      render(<App />);

      await waitFor(() => {
        // Check for enhanced phase elements
        const foundationElement = screen.queryByText(/Multi-Spectrum Foundation/i);
        const aiOptElement = screen.queryByText(/AI Optimization/i);
        const learningElement = screen.queryByText(/Continuous Learning/i);
        const integrationElement = screen.queryByText(/Production Integration/i);

        // At least one should be present
        expect(foundationElement || aiOptElement || learningElement || integrationElement).toBeTruthy();
      });
    });
  });

  describe('API Integration', () => {
    test('fetchVirtuousCycleStatus handles successful response', async () => {
      // Mock axios create and get method
      const mockAxiosInstance = {
        get: vi.fn().mockResolvedValue({ data: mockApiResponse }),
        interceptors: {
          response: {
            use: vi.fn()
          }
        }
      };

      mockedAxios.create.mockReturnValue(mockAxiosInstance);

      const result = await fetchVirtuousCycleStatus();

      expect(result).toEqual(mockApiResponse);
      expect(mockAxiosInstance.get).toHaveBeenCalledWith('/v1/virtuous-cycle/status');
    });

    test('fetchVirtuousCycleStatus handles API error gracefully', async () => {
      // Mock axios create with error
      const mockAxiosInstance = {
        get: vi.fn().mockRejectedValue(new Error('API Error')),
        interceptors: {
          response: {
            use: vi.fn()
          }
        }
      };

      mockedAxios.create.mockReturnValue(mockAxiosInstance);

      const result = await fetchVirtuousCycleStatus();

      // Should return mock data on error
      expect(result).toHaveProperty('monitoring_active');
      expect(result).toHaveProperty('metrics');
      expect(result.metrics).toHaveProperty('traces_processed');
    });
  });

  describe('Enhanced Features', () => {
    test('transformToDashboardData processes API data correctly', () => {
      const result = transformToDashboardData(mockApiResponse);

      // Check enhanced structure
      expect(result).toHaveProperty('kpi');
      expect(result).toHaveProperty('phases');
      expect(result).toHaveProperty('activity');
      expect(result).toHaveProperty('charts');
      expect(result).toHaveProperty('systemStatus');

      // Check enhanced KPI data
      expect(result.kpi).toHaveProperty('qualityScore');
      expect(result.kpi).toHaveProperty('tracesProcessed');
      expect(result.kpi).toHaveProperty('optimizationsTriggers');
      expect(result.kpi).toHaveProperty('systemUptime');

      // Check enhanced phases
      expect(result.phases).toHaveLength(4);
      expect(result.phases[0]).toHaveProperty('phase', '1');
      expect(result.phases[0]).toHaveProperty('title', 'Multi-Spectrum Foundation');
    });

    test('handles warning states correctly', () => {
      const warningApiResponse = {
        ...mockApiResponse,
        component_status: {
          langsmith_client: true,
          quality_collector: true,
          phase2_orchestrator: false, // This should trigger warning
          phase3_orchestrator: false,
          phase4_orchestrator: false
        }
      };

      const result = transformToDashboardData(warningApiResponse);

      // Check that warning states are properly set
      const aiOptPhase = result.phases.find(p => p.phase === '2');
      expect(aiOptPhase.status).toBe('warning');
    });
  });

  describe('Error Handling', () => {
    test('displays error state when API fails', async () => {
      // Mock axios create with persistent error
      const mockAxiosInstance = {
        get: vi.fn().mockRejectedValue(new Error('Network Error')),
        interceptors: {
          response: {
            use: vi.fn()
          }
        }
      };

      mockedAxios.create.mockReturnValue(mockAxiosInstance);

      render(<App />);

      await waitFor(() => {
        // Should still render with mock data, not show error UI
        expect(screen.getByText(/tilores_X AI Dashboard/i)).toBeInTheDocument();
      });
    });
  });
});
